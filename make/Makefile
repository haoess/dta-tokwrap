##-*- Mode: Makefile -*-
##
## File: Makefile
## Author: Bryan Jurish <jurish@bbaw.de>
## Description:
##  + top-level makefile for corpus preparation via dta-tokwrap
## Usage:
##  + DO NOT edit this file (unless you *really* know what you're doing)
##  + Copy the file "User.mak" which came with the distribution to
##    a new file, e.g. "MyConfig.mak", and edit the new file to suit your
##    needs
##  + Call make with "config=MyConfig.mak" on the command line, e.g.:
##    $ make config=MyConfig.mak all
##  + ... you atta be in buttah ...
##======================================================================

##======================================================================
## Configuration: User

config ?= User.mak
include $(config)

##======================================================================
## Configuration: Defaults

##--------------------------------------------------------------
## Configuration: Defaults: sources & targets

xmldir ?= .
xml    ?= $(wildcard $(xmldir),*.chr.xml) $(wildcard $(xmldir),*.char.xml)
outdir = .
tmpdir = $(outdir)

corpus ?= $(notdir $(xmldir)) ##-- UNUSED

XML = $(notdir $(xml))

##--------------------------------------------------------------
## Configuration: Defaults: tokwrap

## TOKWRAP_OPTS
##  + all options for dta-tokwrap.perl
TOKWRAP_OPTS = -keep

ifeq "$(inplace)" ""
ifneq "$(shell test -f ../src/dtatw-mkindex.c && echo yup)" "yup"
inplace=no
else
inplace=yes
endif
endif

ifeq "$(inplace)" "yes"
TOKWRAP_OPTS += -inplace
else
TOKWRAP_OPTS += -noinplace
endif

##--------------------------------------------------------------
## Configuration: Defaults: dta-tokwrap.perl: behavior

ifeq "$(dummytok)" ""
ifeq "$(shell which dwds_tomasotath)" ""
override dummytok := yes
else
override dummytok := no
endif
endif

ifeq "$(dummytok)" "no"
#TOKWRAP_OPTS += -nodummytok -weak-hints
TOKWRAP_OPTS += -nodummytok
else
#TOKWRAP_OPTS += -dummytok -strong-hints
TOKWRAP_OPTS += -dummytok
endif

ifneq "$(abbrevlex)" ""
TOKWRAP_OPTS += -abbrev-lex="$(abbrevlex)"
endif

ifneq "$(mwelex)" ""
TOKWRAP_OPTS += -mwe-lex="$(mwelex)"
endif

##--------------------------------------------------------------
## Configuration: Defaults: dta-tokwrap.perl: verbosity & logging

ifneq "$(verbose)" ""
TOKWRAP_OPTS += -verbose=$(verbose)
endif

ifneq "$(loglevel)" ""
TOKWRAP_OPTS += -log-level="$(loglevel)"
endif

ifneq "$(logfile)" ""
TOKWRAP_OPTS += -log-file="$(logfile)"
endif

ifneq "$(stderr)" ""
ifeq "$(stderr)" "no"
TOKWRAP_OPTS += -nostderr
else
TOKWRAP_OPTS += -stderr  ##-- default
endif
endif

ifneq "$(trace)" ""
ifeq "$(trace)" "no"
TOKWRAP_OPTS += -notrace
else
TOKWRAP_OPTS += -trace
endif
endif

ifneq "$(profile)" ""
ifneq "$(profile)" "no"
TOKWRAP_OPTS += -profile
else
TOKWRAP_OPTS += -noprofile
endif
endif

##-- user options
TOKWRAP_OPTS += $(twopts)

##--------------------------------------------------------------
## Configuration: Defaults: programs & in-place execution

PERL = perl

ifeq "$(inplace)" "yes"

XSL_DIR = ../scripts

PROG_DIR  = ../src/
PROG_DEPS = $(wildcard $(PROG_DIR)*.c) $(wildcard $(PROG_DIR)*.h) $(wildcard $(PROG_DIR)*.l)

SCRIPT_DIR  = ../scripts/
SCRIPT_DEPS = $(wildcard $(SCRIPT_DIR)dtatw-*.perl)

TOKWRAP_DIR  = ../DTA-TokWrap
TOKWRAP_SRC  = $(TOKWRAP_DIR)/dta-tokwrap.perl
#TOKWRAP      = $(PERL) -Mlib=$(TOKWRAP_DIR)/blib/lib $(TOKWRAP_DIR)/blib/script/dta-tokwrap.perl $(TOKWRAP_OPTS)
TOKWRAP      = ./dta-tokwrap.perl $(TOKWRAP_OPTS)
TOKWRAP_DEPS = $(TOKWRAP_SRC)

else

XSL_DIR = /usr/local/share/dta-tokwrap/stylesheets

PROG_DIR  =
PROG_DEPS =

SCRIPT_DIR  =
SCRIPT_DEPS =

TOKWRAP      =dta-tokwrap.perl $(TOKWRAP_OPTS)
TOKWRAP_DEPS =

endif

##--------------------------------------------------------------
## Configuration: Defaults: archiving & distribution

ARC_TARGETS ?= \
	Makefile \
	User.mak \
	$(config) \
	$(logfile) \
	$(XML:.xml=.t.xml) \
	$(XML:.xml=.s.xml) \
	$(XML:.xml=.w.xml) \
	$(XML:.xml=.a.xml)

##--------------------------------------------------------------
## Configuration: Defaults: cleanup

CLEAN_DEPS ?=
CLEAN_FILES ?=

REALCLEAN_DEPS += clean
REALCLEAN_FILES += \
	$(filter-out $(xml),$(XML)) \



##======================================================================
## Rules: top-level

all: t-xml s-xml w-xml a-xml

extra: cab-xml cws-xml cws-noc-fmt-xml summary

summary: rw-summary unk-summary

.SECONDARY: 

##======================================================================
## Rules: show configuration

config: twconfig

twconfig:
	@echo "inplace=$(inplace)"
	@echo "dummytok=$(dummytok)"
	@echo "abbrevlex=$(abbrevlex)"
	@echo "mwelex=$(mwelex)"
	@echo "verbose=$(verbose)"
	@echo "loglevel=$(loglevel)"
	@echo "logfile=$(logfile)"
	@echo "stderr=$(stderr)"
	@echo "trace=$(trace)"
	@echo "profile=$(profile)"
	@echo "TOKWRAP=$(TOKWRAP)"

srcconfig:
	@echo "xmldir=$(xmldir)"
	@echo "xml=$(xml)"
	@echo "XML=$(XML)"

##======================================================================
## Rules: link in sources (don't rely on this!)

#$(XML): xml
xml: $(xml)
	rm -f $(filter-out $(xml),$(XML))
	ln -s $^ .

no-xml:
	test -z "$(filter-out $(xml),$(XML))" || rm -f $(filter-out $(xml),$(XML))
	rm -f xml.stamp

REALCLEAN_DEPS += no-xml

##======================================================================
## Rules: generic XML stuff

##-- pretty-printing: *.fmt[.xml]
%.fmt: %w
	xmllint --format -o $@ $<
%.fmt.xml: %.xml
	xmllint --format -o $@ $<
CLEAN_FILES += *.fmt *.fmt.xml

##-- namespace removal: *.nons[.xml]
%.nons: % programs
	$(PROG_DIR)dtatw-rm-namespaces $< $@
%.nons.xml: %.xml $(RMNS)
	$(PROG_DIR)dtatw-rm-namespaces $< $@
CLEAN_FILES += *.nons *.nons.xml

##-- character removal *.noc[.xml]
%.noc: % scripts
	$(SCRIPT_DIR)dtatw-rm-c.perl $< > $@ || (rm -f $@; false)
%.noc.xml: %.xml scripts
	$(SCRIPT_DIR)dtatw-rm-c.perl $< > $@ || (rm -f $@; false)
CLEAN_FILES += *.noc *.noc.xml

##======================================================================
## Rules: mkindex: xml -> xx=(cx,sx,tx)

xx: cx sx tx

cx: $(XML:.xml=.cx)
sx: $(XML:.xml=.sx)
tx: $(XML:.xml=.tx)

no-cx: ; rm -f $(XML:.xml=.cx)
no-sx: ; rm -f $(XML:.xml=.sx)
no-tx: ; rm -f $(XML:.xml=.tx)

no-xx: no-cx no-sx no-tx

##-- xml -> (cx,sx,tx): individual rule
%.xx: %.cx %.sx %.tx
%.cx: %.cx %.sx %.tx
%.sx: %.cx %.sx %.tx
%.tx: %.cx %.sx %.tx

%.cx %.sx %.tx: $(xmldir)/%.xml tokwrap
ifeq "$(TOKWRAP_ALL)" "yes"
	$(TOKWRAP) -t mkindex $<
else
	$(PROG_DIR)dtatw-mkindex $< $*.cx $*.sx $*.tx
endif


CLEAN_FILES += *.cx *.sx *.tx *.xx

##-- aliases for debugging
sx-fmt: $(XML:.xml=.sx.fmt)
no-sx-fmt: ; rm -f *.sx.fmt

sx-nons: $(XML:.xml=.sx.nons)
no-sx-nons: ; rm -f *.sx.nons *.sx.nons.fmt

sx-nons-fmt: $(XML:.xml=.sx.nons.fmt)
no-sx-nons-fmt: ; rm -f *.sx.nons.fmt
CLEAN_FILES += *.sx.nons *.sx.fmt *.sx.nons.fmt *.sx.fmt.nons

##======================================================================
## Rules: serialization (serialized block index: bx0)

bx0: $(XML:.xml=.bx0)
%.bx0: %.sx tokwrap
	$(TOKWRAP) -t mkbx0 $(xmldir)/$*.xml

no-bx0: ; rm -f *.bx0 bx0.stamp
CLEAN_FILES += *.bx0 bx0.stamp

##======================================================================
## Rules: serialized text + index (bx, txt)

serialize: txt

bx: bx-txt
txt: bx-txt
bx-txt: $(XML:.xml=.bx)

%.bx:  %.bx %.txt
%.txt: %.bx %.txt

%.bx: %.bx0 %.tx tokwrap
	$(TOKWRAP) -t mktxt $(xmldir)/$*.xml

%.txt: %.bx0 %.tx tokwrap
	$(TOKWRAP) -t mktxt $(xmldir)/$*.xml

no-bx-txt: ; rm -f *.bx *.txt
no-bx: no-bx-txt
no-txt: no-bx-txt
CLEAN_FILES += *.bx *.txt

##======================================================================
## Rules: tokenization

t: $(XML:.xml=.t)
%.t: %.txt tokwrap
ifeq "$(TOKENIZER)" ""
	$(TOKWRAP) -t tokenize $(xmldir)/$*.xml
else
	$(TOKENIZER) $< > $@ || (rm -f $@; false)
endif

no-t: ; rm -f *.t
CLEAN_FILES += *.t

##======================================================================
## Rules: tokenized: master xml output

t-xml: $(XML:.xml=.t.xml)

%.t.xml: %.t %.cx %.bx tokwrap
ifeq "$(TOKWRAP_ALL)" "yes"
	$(TOKWRAP) -t tok2xml $(xmldir)/$*.xml
else
	$(PROG_DIR)dtatw-tok2xml $< $*.cx $*.bx $@ $*.xml
endif

no-t-xml: ; rm -f *.t.xml
CLEAN_FILES += *.t.xml

##======================================================================
## Rules: tokenized: xml-t: master xml output -> .tt

%.t.xml.t: $(XSL_DIR)/dtatw-txml2tt.xsl %.t.xml
	xsltproc --param w_loc 0 --param w_cab 0 --param w_a 0 -o "$@" $^

%.t.xml.tt: $(XSL_DIR)/dtatw-txml2tt.xsl %.t.xml
	xsltproc -o "$@" $^

xml-t: t-xml-t
xml-tt: t-xml-tt
t-xml-t: $(XML:.xml=.t.xml.t)
t-xml-tt: $(XML:.xml=.t.xml.tt)

no-xml-t: no-t-xml-t
no-xml-tt: no-t-xml-tt
no-t-xml-t: ; rm -f *.t.xml.t
no-t-xml-tt: ; rm -f *.t.xml.tt

CLEAN_FILES += *.t.xml.t *.t.xml.tt

##======================================================================
## Rules: standoff (via C utilities)

##--------------------------------------------------------------
## standoff: top-level
standoff: s-xml w-xml a-xml
no-standoff: no-s-xml no-w-xml no-a-xml

%-standoff: %.s.xml %.w.xml %.a.xml

##--------------------------------------------------------------
## standoff: .s.xml
s-xml: $(XML:.xml=.s.xml)

%.s.xml: %.t.xml tokwrap
ifeq "$(TOKWRAP_ALL)" "yes"
	$(TOKWRAP) -t sosxml $(xmldir)/$*.xml
else
	$(PROG_DIR)dtatw-txml2sxml $< $@ $*.w.xml
endif

no-s-xml: ; rm -f *.s.xml
CLEAN_FILES += *.s.xml

##--------------------------------------------------------------
## standoff: .w.xml
w-xml: $(XML:.xml=.w.xml)

%.w.xml: %.t.xml tokwrap
ifeq "$(TOKWRAP_ALL)" "yes"
	$(TOKWRAP) -t sowxml $(xmldir)/$*.xml
else
	$(PROG_DIR)dtatw-txml2wxml $< $@ $*.xml
endif

no-w-xml: ; rm -f *.w.xml
CLEAN_FILES += *.w.xml

##--------------------------------------------------------------
## standoff: .a.xml
a-xml: $(XML:.xml=.a.xml)
%.a.xml: %.t.xml tokwrap
ifeq "$(TOKWRAP_ALL)" "yes"
	$(TOKWRAP) -t soaxml $(xmldir)/$*.xml
else
	$(PROG_DIR)dtatw-txml2axml $< $@ $*.w.xml
endif

no-a-xml: ; rm -f *.a.xml
CLEAN_FILES += *.a.xml


##======================================================================
## Rules: source+standoff integration ("splicing")

splice: cw-xml cws-xml
splice-noc: cws-noc-fmt-xml
cws-noc-fmt-xml: $(XML:.xml=.cws.noc.fmt.xml)

##-- splice: (.char.xml + .w.xml) --> .cw.xml
cw-xml: $(XML:.xml=.cw.xml)
%.cw.xml: $(xmldir)/%.xml %.w.xml scripts
	$(SCRIPT_DIR)dtatw-add-w.perl -q -o $@ $< $*.w.xml || (rm -f $@; false)

no-cw-xml: ; rm -r *.cw.xml
CLEAN_FILES += *.cw.xml

##-- splice: (.cw.xml + .s.xml) --> .cws.xml
cws-xml: $(XML:.xml=.cws.xml)
%.cws.xml: %.cw.xml %.s.xml scripts
	$(SCRIPT_DIR)dtatw-add-s.perl -q -o $@ $< $*.s.xml  || (rm -f $@; false)

no-cws-xml: ; rm -r *.cws.xml
CLEAN_FILES += *.cws.xml

##======================================================================
## Rules: DTA::CAB analysis: direct: (v1): .t.xml -> .dta-cab.xml.bytok
## + slow: 673 tok/sec
## + gets us "true" dta-cab XML format:
#    <sentences xml:base="ex2a.xml">...
#    <s xml:id="s1">...
#     <w xml:id="w1" b="13 6" t="Critik" c="c1 c2 c3 c4 c5 c6">
#       <xlit t="Critik" isLatin1="1" isLatinExt="1"/>
#       <lts>
#         <a hi="kRitik" w="0"/>
#       </lts>
#       <eqpho>
#         <a t="Critik"/>
#         <a t="Kritik"/>
#       </eqpho>
#       <morph/>
#       <msafe safe="0"/>
#       <rewrite>
#         <a hi="Kritik" w="5">
#           <lts>
#             <a hi="kRitik" w="0"/>
#           </lts>
#           <morph>
#             <a hi="Kritik[_NN][abstr][fem][sg]*" w="0"/>
#             <a hi="Kritik[_NN][k_l_h_sozeinh][fem][sg]*" w="0"/>
#           </morph>
#         </a>
#       </rewrite>
#     </w>

cab-xml-bytok: dta-cab-xml-bytok
dta-cab-xml-bytok: $(XML:.xml=.dta-cab.xml.bytok)

%.dta-cab.xml.bytok: %.t.xml
	dta-cab-xmlrpc-client.perl $(cab_options) -s=$(cab_server) -a=$(cab_analyzer) -raw -ic=Xml -oc=Xml -ol=1 -o="$@" "$<" \
	  || (rm -f "$@"; false)

no-dta-cab-xml-bytok: ; rm -f *.dta-cab.xml.bytok
no-cab-xml-bytok: no-dta-cab-xmlw-bytok
CLEAN_FILES += *.dta-cab.xml.bytok

##======================================================================
## Rules: DTA::CAB Analysis: type-wise

##--------------------------------------------------------------
## Token->Type extraction: .t.xml.t -> .types.t

types: types-t
types-t: $(XML:.xml=.types.t)
%.types.t: %.t.xml.tt
	cut -d$$'\t' -f 1 $< | grep -v '^%%' | grep . | sort | uniq > $@ || (rm -f $@; false)

no-types-t: ; rm -f *.types.t
CLEAN_FILES += *.types.t

##--------------------------------------------------------------
## Type-wise analysis (DTA::CAB): types.t -> types.dta-cab.tt

types-tt: types-cab-tt
types-cab-tt: $(XML:.xml=.types.dta-cab.tt)
%.types.dta-cab.tt: %.types.t
	dta-cab-xmlrpc-client.perl $(cab_options) -s $(cab_server) -a $(cab_analyzer) -raw -ic=TT -oc=TT -ol=1 -o "$@" "$<" \
	  || (rm -f "$@"; false)

no-types-tt: no-types-cab-tt
no-types-cab-tt: ; rm -f *.types.dta-cab.tt
CLEAN_FILES += *.types.dta-cab.tt

##--------------------------------------------------------------
## Type->Token back-mapping: (.types.dta-cab.tt, .t.xml.tt) -> (.dta-cab.tt)

cab-tt: dta-cab-tt
dta-cab-tt: $(XML:.xml=.toks.dta-cab.tt)
%.toks.dta-cab.tt: %.types.dta-cab.tt %.t.xml.tt scripts
	$(SCRIPT_DIR)dtatw-tt-dictapply.perl $< $*.t.xml.tt > $@ || (rm -f $@; false)

no-cab-tt: no-dta-cab-tt
no-dta-cab-tt: ; rm -f *.dta-cab.tt
CLEAN_FILES += *.dta-cab.tt

##--------------------------------------------------------------
## DTA::CAB XML (from token-expansion of type-wise analysis): .toks.dta-cab.tt -> .dta-cab.xml

cab-xml: dta-cab-xml
dta-cab-xml: $(XML:.xml=.dta-cab.xml)
%.dta-cab.xml: %.toks.dta-cab.tt scripts
#	dta-cab-convert.perl -verbose=info $< -oc=Xml -ol=1 -o $@  ##-- slow
	$(SCRIPT_DIR)dtatw-cabtt2xml.perl $< > $@ || (rm -f $@; false)

no-cab-xml: no-dta-cab-xml
no-dta-cab-xml: ; rm -f *.dta-cab.xml
CLEAN_FILES += *.dta-cab.xml

##--------------------------------------------------------------
## DTA::CAB: cleanup

cab: cab-xml

no-cab: no-dta-cab
no-dta-cab: ; rm -f *.dta-cab.*

##======================================================================
## Rules: Summaries

##--------------------------------------------------------------
## Rules: Summaries: types

corpus-types: $(corpus).types
$(corpus).types: $(XML:.xml=.types.t)
	cat $^ | grep -v '^%%' | grep . | sort | uniq > $@ || (rm -f $@; false)

corpus-typf: $(corpus).ftypes
$(corpus).typf: $(XML:.xml=.t)
	cat $^ | grep -v '^%%' | cut -d$$'\t' -f1 | grep . | sort | uniq -c \
	| sed -e's/^[ ]*\([0-9][0-9]*\) \(.*\)/\2\t\[freq\] \1/1' \
	> $@ || (rm -f $@; false)

REALCLEAN_FILES += *.types *.typf

##--------------------------------------------------------------
## Rules: Summaries: dict

corpus-dict: $(corpus).dict
$(corpus).dict: $(XML:.xml=.types.dta-cab.tt)
	cat $^ | grep -v '^%%' | grep . | sort | uniq > $@ || (rm -f $@; false)

corpus-dictf: $(corpus).dictf
%.dictf: %.typf %.dict scripts
	$(SCRIPT_DIR)dtatw-tt-dictapply.perl $*.dict $*.typf > $@ || (rm -f $@; false)

REALCLEAN_FILES += *.dict *.dictf

##--------------------------------------------------------------
## Rules: Summaries: rewrite

rw-summary: $(corpus).rw-summary
corpus-rw: $(corpus).rw-summary
%.rw-summary: %.dictf
	cat $^ | fgrep '[rw]' \
	| sed -e's/^\([^\t]*\)\t\[freq\] \([^\t]*\).*\t\(\[rw\][^\t]*\).*/\1\t\2\t\3/1' - \
	| sort -t$$'\t' -k2 -nr > $@ || (rm -f $@; false)

unk-summary: $(corpus).unk-summary
corpus-unk: $(corpus).unk-summary
%.unk-summary: %.dictf
	cat $^ | fgrep -v '[rw]' | fgrep -v '[morph]' | egrep -v '^[^'$$'\t'']*[[:digit:][:punct:]]' \
	| sed -e's/^\([^\t]*\)\t\[freq\] \([^\t]*\).*/\1\t\2/1' - \
	| sort -t$$'\t' -k2 -nr > $@ || (rm -f $@; false)

REALCLEAN_FILES += *.rw-summary *.unk-summary

##======================================================================
## Rules: archiving

arc: $(arcfile)

arcdir: $(arcname)/stamp

$(arcname)/stamp: $(ARC_TARGETS) $(xml)
	rm -rf $(arcname)
	mkdir $(arcname)
	mkdir $(arcname)/data
	for f in $(ARC_TARGETS); do \
	  test -e $(arcname)/data/$$f || ln `readlink -f $$f` $(arcname)/data/`basename $$f`; \
	done
	if test "$(arc_want_sources)" = "yes"; then \
	  mkdir $(arcname)/sources; \
	  for f in $(xml); do \
	    ln `readlink -f $$f` $(arcname)/sources/`basename $$f` ; \
	  done; \
	fi
	date -I > $@

no-arcdir:
	rm -rd $(arcname)

$(arcfile): arcdir
	rm -rf $(arcfile)
	GZIP="$(arc_gzip)" tar cvzf $@ $(arcname)
	@echo "Created archive $@"

no-arc: no-arcdir
	rm -f $(arcfile)

##======================================================================
## Rules: install

ifeq "$(USER)" "root"
 INSTALL_DATA = install -o $(install_user) -g $(install_group) -m $(install_mode)
 INSTALL_DIR  = install -o $(install_user) -g $(install_group) -m $(install_dirmode) -d
else
 INSTALL_DATA = install -m $(install_mode)
 INSTALL_DIR  = install -m $(install_dirmode) -d
endif

INSTALL_FILES =
ifneq "$(install_makefile)" "no"
 INSTALL_FILES += Makefile *.mak $(config)
endif

ifneq "$(install_sources)" "no"
 INSTALL_FILES += $(XML)
endif

ifneq "$(install_standoff)" "no"
 INSTALL_FILES += $(XML:.xml=.t.xml)
 INSTALL_FILES += $(XML:.xml=.s.xml)
 INSTALL_FILES += $(XML:.xml=.w.xml)
 INSTALL_FILES += $(XML:.xml=.a.xml)
endif


##======================================================================
## Rules: utility programs (inplace="yes" only!)

programs: $(PROG_DEPS)
ifeq "$(inplace)" "yes"
	$(MAKE) -C "$(PROG_DIR)" all
else
	true
endif

##======================================================================
## Rules: perl module (inplace="yes" only!)

##--
ifeq "$(inplace)" "yes"

#tokwrap: programs pm
tokwrap: programs
scripts: $(SCRIPT_DEPS)

pm: $(TOKWRAP_DIR)/Makefile
	$(MAKE) -C $(TOKWRAP_DIR)

$(TOKWRAP_DIR)/Makefile: $(TOKWRAP_DIR)/Makefile.PL
	(cd $(TOKWRAP_DIR); $(PERL) Makefile.PL)

else
##-- ifeq "$(inplace)" "yes": else

tokwrap:
	true

scripts:
	true

pm:
	true

endif
##-- ifeq "$(inplace)" "yes": endif


##======================================================================
## Rules: cleanup

no-log: nolog
nolog: ; rm -f *.log
REALCLEAN_FILES += *.log

clean: $(CLEAN_DEPS)
	rm -f $(CLEAN_FILES)

realclean: $(REALCLEAN_DEPS)
	rm -f $(REALCLEAN_FILES)
