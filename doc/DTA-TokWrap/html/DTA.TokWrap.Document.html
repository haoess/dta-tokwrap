<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<link rel="stylesheet" href="dtatw.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" valign="middle">
<big><strong><span class="_podblock_">&nbsp;</span></strong></big>
</td></tr>
</table>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Globals">Globals</a></li>
      <li><a href="#Constructors-etc">Constructors etc.</a></li>
      <li><a href="#Methods:-Pseudo-I-O">Methods: Pseudo-I/O</a></li>
      <li><a href="#Methods:-pseudo-pseudo-make">Methods: pseudo-pseudo-make</a></li>
      <li><a href="#Methods:-Low-Level:-generator-subclass-wrappers">Methods: Low-Level: generator-subclass wrappers</a></li>
      <li><a href="#Methods:-Member-I-O">Methods: Member I/O</a></li>
      <li><a href="#Methods:-Profiling">Methods: Profiling</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#SEE-ALSO1">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DTA::TokWrap::Document - DTA tokenizer wrappers: document wrapper</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> use DTA::TokWrap::Document;
 
 ##========================================================================
 ## Constructors etc.
 
 $doc = $CLASS_OR_OBJECT-&gt;new(%args);
 %defaults = $CLASS-&gt;defaults();
 $doc = $doc-&gt;init();
 $doc-&gt;DESTROY();
 
 ##========================================================================
 ## Methods: Pseudo-I/O
 
 $newdoc = CLASS_OR_OBJECT-&gt;open($xmlfile,%docNewOptions);
 $bool = $doc-&gt;close();
 @notempkeys = $doc-&gt;notempkeys();
 @tempfiles = $doc-&gt;tempfiles();
 
 ##========================================================================
 ## Methods: pseudo-pseudo-make
 
 $bool = $doc-&gt;genKey($key);
 $keyval_or_undef = $doc-&gt;makeKey($key);
 
 ##========================================================================
 ## Methods: Low-Level: generator-subclass wrappers
 
 $doc_or_undef = $doc-&gt;mkindex();
 $doc_or_undef = $doc-&gt;mkbx0();
 $doc_or_undef = $doc-&gt;mkbx();
 $doc_or_undef = $doc-&gt;tokenize();
 $doc_or_undef = $doc-&gt;tok2xml();
 $doc_or_undef = $doc-&gt;txmlanno();
 
 ##========================================================================
 ## Methods: Member I/O
 
 $bx0doc_or_undef    = $doc-&gt;loadBx0File();
 $cxdata_or_undef    = $doc-&gt;loadBxFile();
 $cxdata_or_undef    = $doc-&gt;loadCxFile();
 \$tokdata_or_undef  = $doc-&gt;loadTokFile();
 \$xtokdata_or_undef = $doc-&gt;loadXtokFile();
 $xtokDoc            = $doc-&gt;xtokDoc();
 \$xmlbuf_or_undef   = $doc-&gt;loadXmlData();
 \$txtbuf_or_undef   = $doc-&gt;loadTxtData();
 
 $file_or_undef = $doc-&gt;saveBx0File();
 $file_or_undef = $doc-&gt;saveBxFile();
 $file_or_undef = $doc-&gt;saveTxtFile();
 $file_or_undef = $doc-&gt;saveTokFile();
 $file_or_undef = $doc-&gt;saveXtokFile();
 $file_or_undef = $doc-&gt;saveTcfFile();
  
 ##========================================================================
 ## Methods: Profiling
 
 $ntoks_or_undef = $doc-&gt;nTokens();
 $nxbytes_or_undef = $doc-&gt;nXmlBytes();
 </code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>DTA::TokWrap::Document provides a perl class for representing a single DTA base-format XML file and associated indices. Together with the <a>DTA::TokWrap</a> module, this class comprises the top-level API of the DTA::TokWrap distribution.</p>

<h2 id="Globals">Globals</h2>

<dl>

<dt id="ISA">@ISA</dt>
<dd>

<p>DTA::TokWrap::Document inherits from <a>DTA::TokWrap::Base</a>.</p>

</dd>
<dt id="TOKENIZE_CLASS">$TOKENIZE_CLASS</dt>
<dd>

<p>$TOKENIZE_CLASS</p>

<p>Default tokenizer sub-processor class (default=&#39;<a>DTA::TokWrap::Processor::tokenize</a>&#39;).</p>

</dd>
<dt id="Variables:-CX_ID-CX_XOFF-CX_XLEN-CX_TOFF-CX_TLEN-CX_TEXT-CX_ATTRS">Variables: ($CX_ID,$CX_XOFF,$CX_XLEN,$CX_TOFF,$CX_TLEN,$CX_TEXT,$CX_ATTRS)</dt>
<dd>

<p>Field indices in .cx files generated by the <a href="#mkindex">mkindex()</a> method.</p>

</dd>
</dl>

<h2 id="Constructors-etc">Constructors etc.</h2>

<dl>

<dt id="new">new</dt>
<dd>

<pre><code> $doc = $CLASS_OR_OBJECT-&gt;new(%args);</code></pre>

<p>Low-level constructor for document wrapper object. You should probably use either <a>DTA::TokWrap-&gt;open()</a> or <a href="#open">DTA::TokWrap::Document-&gt;open()</a> instead of calling this constructor directly.</p>

<p>%args, %$doc:</p>

<pre><code> ##-- Document class
 class =&gt; $class,      ##-- delegate call to $class-&gt;new(%args)
 ##
 ##-- Source data
 xmlfile =&gt; $xmlfile,  ##-- source filename
 xmlbase =&gt; $xmlbase,  ##-- xml:base for generated files (default=basename($xmlfile))
 xmldata =&gt; $xmldata,  ##-- source buffer (for addws, tcfencode)
 ##
 ##-- pseudo-make options
 traceMake =&gt; $level,  ##-- log-level for makeKey() trace (e.g. &#39;debug&#39;; default=undef (none))
 traceGen  =&gt; $level,  ##-- log-level for genKey() trace (e.g. &#39;trace&#39;; default=undef (none))
 traceProc =&gt; $level,  ##-- log-level for document-called processor calls (default=none)
 traceLoad =&gt; $level,  ##-- log-level for load* trace (default=none)
 traceSave =&gt; $level,  ##-- log-level for save* trace (default=none)
 genDummy  =&gt; $bool,   ##-- if true, generator will not actually run (a la `make -n`)
 ##
 ##-- generator data (optional)
 tw =&gt; $tw,              ##-- a DTA::TokWrap object storing individual generators
 traceOpen  =&gt; $leve,    ##-- log-lvel for open() trace (e.g. &#39;info&#39;; default=undef (none))
 traceClose =&gt; $level,   ##-- log-level for close() trace (e.g. &#39;trace&#39;; default=undef (none))
 ##
 ##-- generated data (common)
 outdir =&gt; $outdir,    ##-- output directory for generated data (default=.)
 tmpdir =&gt; $tmpdir,    ##-- temporary directory for generated data (default=$ENV{DTATW_TMP}||$outdir)
 keeptmp =&gt; $bool,     ##-- if true, temporary document-local files will be kept on $doc-&gt;close()
 notmpre =&gt; $regex,    ##-- non-temporary filename regex
 notmpkeys =&gt; $keys,   ##-- non-temporary keys, space-separated list
 outbase =&gt; $filebase, ##-- output basename (default=`basename $xmlbase .xml`)
 format =&gt; $level,     ##-- default formatting level for XML output
 ##
 ##-- mkindex data (see DTA::TokWrap::Processor::mkindex)
 cxfile =&gt; $cxfile,    ##-- character index file (default=&quot;$tmpdir/$outbase.cx&quot;)
 cxdata =&gt; $cxdata,    ##-- character index data (see loadCxFile() method)
 sxfile =&gt; $sxfile,    ##-- structure index file (default=&quot;$tmpdir/$outbase.sx&quot;)
 txfile =&gt; $txfile,    ##-- raw text index file (default=&quot;$tmpdir/$outbase.tx&quot;)
 ##
 ##-- mkbx0 data (see DTA::TokWrap::Processor::mkbx0)
 bx0doc  =&gt; $bx0doc,   ##-- pre-serialized block-index XML::LibXML::Document
 bx0file =&gt; $bx0file,  ##-- pre-serialized block-index XML file (default=&quot;$outbase.bx0&quot;; optional)
 ##
 ##-- mkbx data (see DTA::TokWrap::Processor::mkbx)
 bxdata  =&gt; \@bxdata,  ##-- block-list, see DTA::TokWrap::mkbx::mkbx() for details
 bxfile  =&gt; $bxfile,   ##-- serialized block-index CSV file (default=&quot;$tmpdir/$outbase.bx&quot;; optional)
 txtfile =&gt; $txtfile,  ##-- serialized &amp; hinted text file (default=&quot;$tmpdir/$outbase.txt&quot;; optional)
 txtdata =&gt; $txtdata,  ##-- serialized &amp; hinted text file (used by tcfencode, must be loaded explicitly with loadTxtData())
 ##
 ##-- tokenize data (see DTA::TokWrap::Processor::tokenize, DTA::TokWrap::Processor::tokenize::dummy)
 tokdata0 =&gt; $tokdata0,  ##-- tokenizer output data (slurped string)
 tokfile0 =&gt; $tokfile0,  ##-- tokenizer output file (default=&quot;$tmpdir/$outbase.t0&quot;; optional)
 ##
 ##-- post-tokenize data (see DTA::TokWrap::Processor::tokenize1)
 tokdata1 =&gt; $tokdata1,  ##-- post-tokenizer output data (slurped string)
 tokfile1 =&gt; $tokfile1,  ##-- post-tokenizer output file (default=&quot;$tmpdir/$outbase.t1&quot;; optional)
 ##
 ##-- tokenizer xml data (see DTA::TokWrap::Processor::tok2xml)
 xtokdata =&gt; $xtokdata,  ##-- XML-ified tokenizer output data
 xtokfile =&gt; $xtokfile,  ##-- XML-ified tokenizer output file (default=&quot;$outdir/$outbase.t.xml&quot;)
 xtokdoc  =&gt; $xtokdoc,   ##-- XML::LibXML::Document for $xtokdata (parsed from string)
 ##
 ##-- tokenizer xml annotations (see DTA::TokWrap::Processor::txmlanno)
 axtokdata =&gt; $axtokdata,  ##-- optional external XML annotation data (for splicing into $xtokdata)
 axtokfile =&gt; $axtokfile,  ##-- optional external XML annotation file (for splicing into $xtokfile; default=&quot;$outdir/$outbase.ta.xml&quot;)
 xtokfile0 =&gt; $xtokfile0,  ##-- XML-ified tokenizer output file (default=none or &quot;$outdir/$outbase.t0.xml&quot; if {keeptmp} is true)
 ##
 ##-- ws-splice (see DTA::TokWrap::Processor::addws)
 #cwsdata =&gt; $cwsdata,    ##-- ws-spliced output data (xmlfile with &lt;s&gt; and &lt;w&gt; elements)
 cwsfile =&gt; $cwsfile,    ##-- ws-spliced output file (default=&quot;$outdir/$outbase.cws.xml&quot;)
 ##
 ##-- property-splice (see DTA::TokWrap::Processor::idsplice)
 ## cwstbasebufr =&gt; \$bdata,  ##-- base data-ref for idsplice (xml with //*/@id) [default=\$cwsdata if defined]
 ## cwstbasefile =&gt; $bfile,   ##-- source file for $bdata [default=$cwsfile]
 ## cwstsobufr   =&gt; \$sodata, ##-- standoff data-ref for idsplice (xml with //*/@id, additional attributes and content) [default=\$xtokdata]
 ## cwstsofile   =&gt; $sofile,  ##-- source file for $sodata [default=$xtokfile]
 ## cwstbufr     =&gt; $wstbufr, ##-- idsplice output buffer (base + id-spliced attributes, content) -- available for override, not used by default
 ## cwstfile     =&gt; $wstfile, ##-- idsplice output file [default=&quot;$outdir/$outbase.cwst.xml&quot;]
 ##
 ##-- tcfencode data (see DTA::TokWrap::Processor::tcfencode)
 tcfdoc   =&gt; $tcfdoc,     ##-- XML::LibXML::Document representing TCF-encoded data
 tcffile  =&gt; $tcffile,    ##-- TCF file
 tcflang  =&gt; $lang,       ##-- TCF language attribute (default: &#39;de&#39;)
 ##
 ##-- tcftokenize data (see DTA::TokWrap::Processor::tcftokenize)
 tcftokdoc =&gt; $tcftokdoc,    ##-- XML::LibXML::Document representing tokenized TCF data (== $tcfdoc)
 tcftokfile =&gt; $tcftokfile,  ##-- tcf-tokenized file
 ##
 ##-- tcfdecode0 data (see DTA::TokWrap::Processor::tcfdecode0)
 tcfxfile =&gt; $tcfxfile,   ##-- tcf-decoded base xml file [default=&quot;$tmpdir/$outbase.tcfx&quot;]
 tcfxdata =&gt; $tcfxdata,   ##-- tcf-decoded base xml data
 tcftfile =&gt; $tcftfile,   ##-- tcf-decoded serial text file [default=&quot;$tmpdir/$outbase.tcft&quot;]
 tcftdata =&gt; $tcftdata,   ##-- tcf-decoded serial txt data
 tcfwdata =&gt; $tcfwdata,   ##-- tcf-decoded token data, tt-format: &quot;TEXT\tSID/WID\n&quot;
 tcfwfile =&gt; $tcfwfile,   ##-- tcf-decoded token file, tt-format [default=&quot;$tmpdir/$outbase.tcfw&quot;]
 tcfadata =&gt; $tcfadata,   ##-- tcf-decoded token attributes for idsplice, data
 tcfafile =&gt; $tcfafile,   ##-- tcf-decoded token attributes for idsplice, file [default=&quot;$tmpdir/$outbase.tcfa&quot;]
 ##
 ##-- tcfalign data (PROXIED, see DTA::TokWrap::Processor::tcfalign : uses tokdata1,tokfile1)
 ##-- tcf2txml data (PROXIED, see DTA::TokWrap::Processor::tok2xml : uses tokfile1,cxfile,bxfile,xtokdata)
 ##-- tcfdecode data
 tcfcwsfile =&gt; $tcfcwsfile, ##-- tcf-decoded+aligned+ws-spliced output file (default=&quot;$outdir/$outbase.tcfws.xml&quot;)</code></pre>

</dd>
<dt id="defaults">defaults</dt>
<dd>

<pre><code> %defaults = CLASS-&gt;defaults();</code></pre>

<p>Static object defaults.</p>

</dd>
<dt id="init">init</dt>
<dd>

<pre><code> $doc = $doc-&gt;init();</code></pre>

<p>Set computed object defaults.</p>

</dd>
<dt id="DESTROY">DESTROY</dt>
<dd>

<pre><code> $doc-&gt;DESTROY();</code></pre>

<p>Destructor. Implicitly calls <a href="#close">close()</a>.</p>

</dd>
</dl>

<h2 id="Methods:-Pseudo-I-O">Methods: Pseudo-I/O</h2>

<dl>

<dt id="open">open</dt>
<dd>

<pre><code> $newdoc = $CLASS_OR_OBJECT-&gt;open($xmlfile,%docNewOptions);</code></pre>

<p>Wrapper for <a href="#new">$CLASS_OR_OBJECT-&gt;new()</a>, with some additional sanity checks.</p>

</dd>
<dt id="close">close</dt>
<dd>

<pre><code> $bool = $doc-&gt;close();
 $bool = $doc-&gt;close($is_destructor);</code></pre>

<p>&quot;Closes&quot; document $doc, adding profiling information to $doc-&gt;{tw} if present.</p>

<p>Unlinks any temporary files in $doc unless $doc-&gt;{keeptmp} is true. All %$doc keys ending in &#39;file&#39; are considered &#39;temporary&#39; files, except: xmlfile, xtokfile, sosfile, sowfile, soafile</p>

<p>If $is_destructor is false (default), resets all keys in %$doc to default values (thus making $doc essentially unuseable).</p>

</dd>
<dt id="notempkeys">notempkeys</dt>
<dd>

<pre><code> @notempkeys = $doc-&gt;notempkeys();</code></pre>

<p>Returns list of document keys ending &#39;file&#39; which are not considered &quot;temporary&quot; Used by <a href="#tempfiles">$doc-&gt;tempfiles()</a>.</p>

</dd>
<dt id="tempfiles">tempfiles</dt>
<dd>

<pre><code> @tempfiles = $doc-&gt;tempfiles();</code></pre>

<p>Returns list of temporary filenames which have been generated by $doc, or an empty list if $doc-&gt;{keeptmp} is true. Used by $doc-&gt;close().</p>

<p>Checks $doc-&gt;{&quot;${filekey}_stamp&quot;} to determine whether this document generated the file named by $doc-&gt;{&quot;$filekey&quot;}.</p>

<p>Implementation: returns values of all %$doc keys ending with &#39;file&#39; except for those returned by $doc-&gt;notempkeys()</p>

</dd>
</dl>

<h2 id="Methods:-pseudo-pseudo-make">Methods: pseudo-pseudo-make</h2>

<dl>

<dt id="KEYGEN">%KEYGEN</dt>
<dd>

<pre><code> %KEYGEN = ($dataKey =&gt; $generatorSpec, ...)</code></pre>

<p>Low-level hash mapping data keys to the generating processes (subroutines, classes, ...).</p>

<p>$generatorSpec is one of:</p>

<pre><code> $key      : calls $doc-&gt;can($key)-&gt;($doc)
 \&amp;coderef : calls &amp;coderef($doc)
 \@array   : array of atomic $generatorSpecs (keys or CODE-refs)</code></pre>

</dd>
<dt id="genKey">genKey</dt>
<dd>

<pre><code> $bool = $doc-&gt;genKey($key);
 $bool = $doc-&gt;genKey($key,\%KEYGEN)</code></pre>

<p>(Re-)generate a data key (single step only, ignoring dependencies). An argument $key without a value $KEYGEN{$key} triggers an error.</p>

</dd>
<dt id="makeKey">makeKey</dt>
<dd>

<pre><code> $keyval_or_undef = $doc-&gt;makeKey($key);</code></pre>

<p>Just an alias for $doc-&gt;genKey($key) here, but see <a>DTA::TokWrap::Document::Maker</a> for a more sophisticated implementation</p>

</dd>
</dl>

<h2 id="Methods:-Low-Level:-generator-subclass-wrappers">Methods: Low-Level: generator-subclass wrappers</h2>

<dl>

<dt id="mkindex">mkindex</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;mkindex($mkindex);
 $doc_or_undef = $doc-&gt;mkindex();</code></pre>

<p>see <a>DTA::TokWrap::Processor::mkindex::mkindex()</a>.</p>

</dd>
<dt id="mkbx0">mkbx0</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;mkbx0($mkbx0);
 $doc_or_undef = $doc-&gt;mkbx0();</code></pre>

<p>see <a>DTA::TokWrap::Processor::mkbx0::mkbx0()</a></p>

</dd>
<dt id="mkbx">mkbx</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;mkbx($mkbx);
 $doc_or_undef = $doc-&gt;mkbx();</code></pre>

<p>see <a>DTA::TokWrap::Processor::mkbx::mkbx()</a>.</p>

</dd>
<dt id="tokenize">tokenize</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;tokenize($tokenize);
 $doc_or_undef = $doc-&gt;tokenize();</code></pre>

<p>see <a>DTA::TokWrap::Processor::tokenize::tokenize()</a>, <a>DTA::TokWrap::Processor::tokenize::http::tokenize()</a>, <a>DTA::TokWrap::Processor::tokenize::tomasotath::tokenize()</a>, <a>DTA::TokWrap::Processor::tokenize::dummy::tokenize()</a>.</p>

<p>Default tokenizer subclass is given by package-global $TOKENIZE_CLASS.</p>

</dd>
<dt id="tokenize1">tokenize1</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;tokenize1($tokenize1);
 $doc_or_undef = $doc-&gt;tokenize1();</code></pre>

<p>see <a>DTA::TokWrap::Processor::tokenize1::tokenize1()</a>.</p>

</dd>
<dt id="tok2xml">tok2xml</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;tok2xml($tok2xml);
 $doc_or_undef = $doc-&gt;tok2xml();</code></pre>

<p>see <a>DTA::TokWrap::Processor::tok2xml::tok2xml()</a>.</p>

</dd>
<dt id="txmlanno">txmlanno</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;txmlanno($txmlanno);
 $doc_or_undef = $doc-&gt;txmlanno();</code></pre>

<p>see <a>DTA::TokWrap::Processor::txmlanno::txmlanno()</a>.</p>

</dd>
<dt id="addws">addws</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;addws($addws);
 $doc_or_undef = $doc-&gt;addws();</code></pre>

<p>see <a>DTA::TokWrap::Processor::addws::addws()</a>.</p>

</dd>
<dt id="idsplice">idsplice</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;idsplice($addws);
 $doc_or_undef = $doc-&gt;idsplice();</code></pre>

<p>see <a>DTA::TokWrap::Processor::idsplice::idsplice()</a>.</p>

</dd>
<dt id="tcfencode">tcfencode</dt>
<dd>

<pre><code> $doc_or_undef = $doc-&gt;tcfencode($tcfencode)
 $doc_or_undef = $doc-&gt;tcfencode()</code></pre>

<p>see <a>DTA::TokWrap::Processor::tcfencode::tcfencode()</a>.</p>

</dd>
</dl>

<h2 id="Methods:-Member-I-O">Methods: Member I/O</h2>

<dl>

<dt id="loadBx0File">loadBx0File</dt>
<dd>

<pre><code> $bx0doc_or_undef = $doc-&gt;loadBx0File($filename_or_fh);
 $bx0doc_or_undef = $doc-&gt;loadBx0File();</code></pre>

<p>loads $doc-&gt;{bx0doc} from $filename_or_fh (default=$doc-&gt;{bx0file})</p>

</dd>
<dt id="loadBxFile">loadBxFile</dt>
<dd>

<pre><code> $cxdata_or_undef = $doc-&gt;loadBxFile($bxfile_or_fh,$txtfile_or_fh);
 $cxdata_or_undef = $doc-&gt;loadBxFile();</code></pre>

<p>loads $doc-&gt;{bxdata} from @$doc{qw(bxfile txtfile)}</p>

<p>requires $doc-&gt;{txfile}</p>

</dd>
<dt id="loadCxFile">loadCxFile</dt>
<dd>

<pre><code> $cxdata_or_undef = $doc-&gt;loadCxFile($filename_or_fh);
 $cxdata_or_undef = $doc-&gt;loadCxFile();</code></pre>

<p>loads $doc-&gt;{cxdata} from $filename_or_fh (default=$doc-&gt;{cxfile}).</p>

<p>$doc-&gt;{cxdata} = [ $cx0, ... ], where:</p>

<ul>

<li><p>each $cx = [ $id, $xoff,$xlen, $toff,$tlen, $text, @attrs ]</p>

</li>
<li><p>package globals $CX_ID, $CX_XOFF, etc. are indices for $cx arrays</p>

</li>
</ul>

</dd>
<dt id="loadTokFileN">loadTokFileN</dt>
<dd>

<pre><code> \$tokdata_or_undef = $doc-&gt;loadTokFileN($n,$filename_or_fh);
 \$tokdata_or_undef = $doc-&gt;loadTokFileN($n);</code></pre>

<p>loads $doc-&gt;{&quot;tokdata${n}&quot;} from $filename_or_fh (default=$doc-&gt;{&quot;tokfile${n}&quot;})</p>

</dd>
<dt id="loadTokFile0">loadTokFile0</dt>
<dd>

<pre><code> \$tokdata0_or_undef = $doc-&gt;loadTokFile0(@args)</code></pre>

<p>Wrapper for $doc-&gt;loadTokFileN(0,@args)</p>

</dd>
<dt id="loadTokFile1">loadTokFile1</dt>
<dd>

<pre><code> \$tokdata1_or_undef = $doc-&gt;loadTokFile1(@args)</code></pre>

<p>Wrapper for $doc-&gt;loadTokFileN(1,@args)</p>

</dd>
<dt id="loadXtokFile">loadXtokFile</dt>
<dd>

<pre><code> \$xtokdata_or_undef = $doc-&gt;loadXtokFile($filename_or_fh);
 \$xtokdata_or_undef = $doc-&gt;loadXtokFile();</code></pre>

<p>loads $doc-&gt;{xtokdata} from $filename_or_fh (default=$doc-&gt;{xtokfile})</p>

<p>see also <a href="#xtokDoc">$doc-&gt;xtokDoc()</a>.</p>

</dd>
<dt id="xtokDoc">xtokDoc</dt>
<dd>

<pre><code> $xtokDoc = $doc-&gt;xtokDoc(\$xtokdata);
 $xtokDoc = $doc-&gt;xtokDoc();</code></pre>

<p>parse \$xtokdata (default: \$doc-&gt;{xtokdata}) string into $doc-&gt;{xtokdoc}</p>

<p><b>warning</b>: may call $doc-&gt;tok2xml()</p>

</dd>
<dt id="loadXmlData">loadXmlData</dt>
<dd>

<pre><code> $xmlbuf_or_undef = $doc-E&lt;gt&gt;loadXmlData($filename_or_fh)
 $xmlbuf_or_undef = $doc-E&lt;gt&gt;loadXmlData()</code></pre>

<p>loads $doc-&gt;{xmldata} from $filename_or_fh (default=$doc-&gt;{xmlfile}).</p>

</dd>
<dt id="loadCwsData">loadCwsData</dt>
<dd>

<pre><code> \$xmlbuf_or_undef = $doc-&gt;loadCwsData($filename_or_fh)
 \$xmlbuf_or_undef = $doc-&gt;LoadCwsData()</code></pre>

<p><b>DEPRECATED</b></p>

<p>loads $doc-&gt;{cwsdata} from $filename_or_fh (default=$doc-&gt;{cwsfile}).</p>

</dd>
<dt id="loadTxtData">loadTxtData</dt>
<dd>

<pre><code> \$txtbuf_or_undef = $doc-&gt;loadTxtData($filename_or_fh)
 \$txtbuf_or_undef = $doc-&gt;loadTxtData()</code></pre>

<p>loads $doc-&gt;{txtdata} from $filename_or_fh (default=$doc-&gt;{txtfile})</p>

</dd>
<dt id="saveBx0File">saveBx0File</dt>
<dd>

<pre><code> $file_or_undef = $doc-&gt;saveBx0File($filename_or_fh,$bx0doc,%opts);
 $file_or_undef = $doc-&gt;saveBx0File($filename_or_fh);
 $file_or_undef = $doc-&gt;saveBx0File();</code></pre>

<p>Saves $bx0doc (default=$doc-&gt;{bx0doc}) to $filename_or_fh (default=$doc&gt;{bx0file}=&quot;$doc-&gt;{outdir}/$doc-&gt;{outbase}.bx0&quot;), and sets both $doc&gt;{bx0file} and $doc-&gt;{bx0file_stamp}.</p>

<p>%opts:</p>

<pre><code> format =&gt; $level,  ##-- output format (default=$doc-E&lt;gt&gt;{format})</code></pre>

</dd>
<dt id="saveBxFile">saveBxFile</dt>
<dd>

<pre><code> $file_or_undef = $doc-&gt;saveBxFile($filename_or_fh,\@blocks);
 $file_or_undef = $doc-&gt;saveBxFile($filename_or_fh);
 $file_or_undef = $doc-&gt;saveBxFile();</code></pre>

<p>Saves text-block data \@blocks (default=$doc-&gt;{bxdata}) to $filename_of_fh (default=$doc-&gt;{bxfile}), and sets both $doc-&gt;{bxfile} and $doc-&gt;{bxfile_stamp}.</p>

</dd>
<dt id="saveTxtFile">saveTxtFile</dt>
<dd>

<pre><code> $file_or_undef = $doc-&gt;saveTxtFile($filename_or_fh,\@blocks,%opts);
 $file_or_undef = $doc-&gt;saveTxtFile($filename_or_fh);
 $file_or_undef = $doc-&gt;saveTxtFile();</code></pre>

<p>Saves serialized text extracted from \@blocks (default=$doc-&gt;{bxdata}) to $filename_or_fh (default=$doc-&gt;{txtfile}=&quot;$doc-&gt;{outdir}/$doc-&gt;{outbase}.txt&quot;), and sets both $doc-&gt;{txtfile} and $doc-&gt;{txtfile_stamp}.</p>

<p>%opts:</p>

<pre><code> debug=&gt;$bool,  ##-- if true, debugging text will be printed (and saveBxFile() offsets will be wrong)</code></pre>

</dd>
<dt id="saveTokFileN">saveTokFileN</dt>
<dd>

<pre><code> $file_or_undef = $doc-&gt;saveTokFileN($n,$filename_or_fh,\$tokdata);
 $file_or_undef = $doc-&gt;saveTokFileN($n,$filename_or_fh);
 $file_or_undef = $doc-&gt;saveTokFileN($n);</code></pre>

<p>Saves tokenizer output data string $tokdata (default=$doc-&gt;{&quot;tokdata${n}&quot;}) to $filename_or_fh (default=$doc-&gt;{&quot;tokfile${n}&quot;}=&quot;$doc-&gt;{outdir}/$doc-&gt;{outbase}.t${n}&quot;), and sets both $doc-&gt;{&quot;tokfile${n}&quot;} and $doc-&gt;{&quot;tokfile_stamp${n}&quot;}.</p>

</dd>
<dt id="saveTokFile0">saveTokFile0</dt>
<dd>

<pre><code> $file_or_undef = $doc-&gt;saveTokFile0(@args)</code></pre>

<p>Wrapper for $doc-&gt;saveTokFileN(0,@args)</p>

</dd>
<dt id="saveTokFile1">saveTokFile1</dt>
<dd>

<pre><code> $file_or_undef = $doc-&gt;saveTokFile1(@args)</code></pre>

<p>Wrapper for $doc-&gt;saveTokFileN(1,@args)</p>

</dd>
<dt id="saveXtokFile">saveXtokFile</dt>
<dd>

<pre><code> $file_or_undef = $doc-&gt;saveXtokFile($filename_or_fh,\$xtokdata,%opts);
 $file_or_undef = $doc-&gt;saveXtokFile($filename_or_fh);
 $file_or_undef = $doc-&gt;saveXtokFile();</code></pre>

<p>Saves XML-ified master tokenizer data string $xtokdata (default=$doc-&gt;{xtokdata}) to $filename_or_fh (default=$doc-&gt;{xtokfile}=&quot;$doc-&gt;{outdir}/$doc-&gt;{outbase}.t.xml&quot;), and sets both $doc-&gt;{xtokfile} and $doc-&gt;{xtokfile_stamp}.</p>

</dd>
<dt id="saveTcfFile">saveTcfFile</dt>
<dd>

<pre><code> $file_or_undef = $doc-&gt;saveTcfFile($filename_or_fh,$tcfdoc,%opts)
 $file_or_undef = $doc-&gt;saveTcfFile($filename_or_fh)
 $file_or_undef = $doc-&gt;saveTcfFile()</code></pre>

<p>known %opts:</p>

<pre><code> format =&gt; $level, ##-- formatting level (default=1)</code></pre>

<p>Saves TCF-encoded document $tcfdoc (default=$doc-&gt;{tcfdoc}) to $filename_or_fh (default=$doc-&gt;{tcffile}=&quot;$doc-&gt;{outdir}/$doc-&gt;{outbase}.t.xml&quot;), and sets $doc-&gt;{tcffile_stamp}.</p>

</dd>
</dl>

<h2 id="Methods:-Profiling">Methods: Profiling</h2>

<dl>

<dt id="nTokens">nTokens</dt>
<dd>

<pre><code> $ntoks_or_undef = $doc-&gt;nTokens();</code></pre>

<p>Returns number of tokens in the currently opened document, if known.</p>

</dd>
<dt id="nXmlBytes">nXmlBytes</dt>
<dd>

<pre><code> $nxbytes_or_undef = $doc-&gt;nXmlBytes();</code></pre>

<p>Returns the number of bytes in the base-format XML file, if known (and it <b>should</b> always be known!).</p>

</dd>
</dl>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a>DTA::TokWrap::Intro(3pm)</a>, <a href="dta-tokwrap.perl.pod:.html">dta-tokwrap.perl(1)</a>, ...</p>

<h1 id="SEE-ALSO1">SEE ALSO</h1>

<p><a>DTA::TokWrap::Intro(3pm)</a>, <a href="dta-tokwrap.perl.pod:.html">dta-tokwrap.perl(1)</a>, ...</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Bryan Jurish &lt;moocow@cpan.org&gt;</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>Copyright (C) 2009-2018 by Bryan Jurish</p>

<p>This package is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.14.2 or, at your option, any later version of Perl 5 you may have available.</p>

<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" valign="middle">
<big><strong><span class="_podblock_">&nbsp;</span></strong></big>
</td></tr>
</table>

</body>

</html>


