#!/usr/bin/perl -w

##======================================================================
## Globals

##-- event type identifier for BLOCK events
our $BLOCK_ID = '$BLOCK$';

##-- $rootKey: unique identifier for ROOT block
our $rootKey = '__ROOT__';

##-- $rootBlk: ROOT block (and documentation of BLOCK structure)
our $rootBlk = {
		key    =>$rootKey, ##-- unique block key
		xbegin =>0,        ##-- XML byte offset where this block run begins
		xend   =>0,        ##-- XML byte offset where this block run ends
		tbegin =>0,        ##-- text byte offset where this block run begins
		tend   =>0,        ##-- text byte offset where this block run ends
	       };


##-- @keystack = ($rootKey, ..., $currentKey)
## + mirrors XML element structure
our @keystack = ( $rootKey );

##-- $blk : current block
our $blk = $rootBlk;

##-- %lastkey : $blkType => $lastOpenBlkKey
##  + used for tracking discontinuous segments with '<seg>'
our %lastkey = qw();

##-- $all_implicit_block_elts
##  + if true, new blocks will be created for all elements, unless:
##    - they occur as a daughter of a 'seg' element
##    - or if they occur in %no_implicit_block_elts
our $all_implicit_block_elts = 1;

##-- @implicit_block_elts
## + create new blocks for these elements, unless they occur as a daughter of a 'seg' element
our @implicit_block_elts = (
			    ##-- title page stuff
			    qw(titlePage titlePart docTitle byline docAuthor docImprint pubPlace docDate),
			    ##
			    ##-- main text body
			    qw(p div head text front back body),
			    ##
			    ##-- genre-specific: drama
			    qw(speaker sp stage castList castItem role roleDesc set),
			    ##
			    ##-- citations
			    qw(cit q quote),
			    ##
			    ##-- genre-specific: letters
			    qw(salute dateline opener closer signed),
			    ##
			    ##-- tables
			    qw(table row cell),
			    ##
			    ##-- lists
			    qw(list item),
			    ##
			    ##-- notes etc
			    qw(note argument),
			    ##
			    ##-- misc
			    qw(figure ref fw),
			   );
our %implicit_block_elts = map {$_=>undef} @implicit_block_elts;


our @no_implicit_block_elts = ( qw(lb hi pb g milestone) );
our %no_implicit_block_elts = map {$_=>undef} @no_implicit_block_elts;

##======================================================================
## Subs

## $blk = open_block($oldBlk, $newKey, $xoff, $toff)
##  + opens a new block logically BEFORE current event ($xoff~$toff)
##  + implicitly closes $oldBlk if defined
##  + returns new block
sub open_block {
  my ($_old,$_key,$_xoff,$_toff) = @_;
  $_xoff = $::xoff if (!defined($_xoff));
  $_toff = $::toff if (!defined($_toff));
  $_key = ".$_xoff" if (!defined($_key));
  close_block($_old,$_xoff,$_toff) if (defined($_old));
  return { key=>$_key, xbegin=>$_xoff,xend=>undef, tbegin=>$_toff,tend=>undef };
}

## $blk = close_block($blk, $xoff, $toff)
##  + closes current $blk logically BEFORE current event ($xoff~$toff)
##  + writes a record for the current block run to STDOUT
sub close_block {
  my ($_blk,$_xoff,$_toff) = @_;
  $_blk = $::blk if (!defined($_blk));
  $_xoff = $::xoff if (!defined($_xoff));
  $_toff = $::toff if (!defined($_xoff));

  ##-- only print if block has non-zero text length
  my $_xlen = $_xoff-$_blk->{xbegin};
  my $_tlen = $_toff-$_blk->{tbegin};
  if ($_tlen) { ## || $_xlen
    print join("\t", $BLOCK_ID, $_blk->{xbegin},$_xlen, $_blk->{tbegin},$_tlen, $_blk->{key}), "\n";
  }
  @$_blk{qw(xend tend)} = ($_xoff,$_toff);
  return $_blk;
}

##======================================================================
## MAIN
our ($id,$xoff,$xlen,$toff,$tlen,,$txt);
our ($aid,$axoff,$axlen,$atoff,$atlen,$atxt);

our ($eltname,$elt,@attrs,%attrs);

##-- print header
print
  (
   "%% XML block list file generated by $0\n",
   "%% Command-line: $0 ", join(' ', map {"'$_'"} @ARGV), "\n",
   "%%======================================================================\n",
   "%% \$ID\$\t\$XML_OFFSET\$\t\$XML_LENGTH\$\t\$TXT_OFFSET\$\t\$TXT_LEN\$\t\$KEY\$\n",
  );

$_ = <>;
while (defined($_)) {
  $_buf = $_;
  chomp;
  if (/^%%/) {
    ##-- (mostly) ignore comments
    $_=<>;
    next;
  };

  ##-- parse input
  ($id,$xoff,$xlen,$toff,$tlen,$txt) = split(/\t/,$_);

  ##--------------------------------------------
  if ($id eq '$START$') {
    ##-- start-tag: slurp attributes
    $eltname = $txt;
    @attrs = qw();
    while (<>) {
      #print $_buf;
      $_buf = $_;
      chomp;
      ($aid,$axoff,$axlen,$atoff,$atlen,$atxt) = split(/\t/,$_);
      last if ($aid ne '$ATTR$');
      push(@attrs,$atxt);
    }
    $_ .= "\n"; ##-- for consistency with buffering hacks
    %attrs = @attrs;

    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ($eltname eq 'seg') {
      ##-- start-tag: <seg> element

      if ( ($attrs{part} && $attrs{part} eq 'I') || !($attrs{part}) )
	{
	  ##-- start-tag: <seg>: initial
	  $blk = open_block($blk, "seg.${xoff}", $xoff, $toff);
	  $lastkey{'seg'} = $blk->{key} if ($attrs{part});
	  push(@keystack,$blk->{key});
	}
      elsif ( $attrs{part} ) ## ($attrs{part} eq 'M' || $attrs{part} eq 'F')
	{
	  ##-- start-tag: <seg>: non-initial
	  $blk = open_block($blk, $lastkey{'seg'}, $xoff, $toff); ##-- re-open most recent seg[@part="I"]
	  push(@keystack,$blk->{key});
	}
    }
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elsif (
	   ($all_implicit_block_elts && !exists($no_implicit_block_elts{$eltname}))
	   ||
	   exists($implicit_block_elts{$eltname})
	  ) {
      ##-- start-tag: <note> etc.: implicit block
      if ($blk->{key} !~ /^seg\b/) {
	##-- start-tag: <note> etc.: no parent <seg>: allocate a new block
	$blk = open_block($blk, "${eltname}.${xoff}", $xoff, $toff);
      }
      push(@keystack,$blk->{key});
    }
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    else
      { # ($eltname =~ m/./)
	##-- start-tag: no implicit block: just keep current block running
	push(@keystack, $blk->{key});
	#print STDERR "inheriting block '$blk' for <$eltname>\n";
      }
    #$_=<>; ##-- DON'T slurp more (we got the next line when reading $ATTRS)
  }
  ##--------------------------------------------
  elsif ($id eq '$END$') {
    ##-- end-tag event: update ranges & pop stacks
    $popkey = pop(@keystack);
    $newkey  = $keystack[$#keystack];
    if ($popkey ne $newkey) {
      ##-- block switch: re-open the block we popped from the stack
      #print $_buf;
      $blk = open_block($blk, $newkey, $xoff+$xlen, $toff+$tlen);
      #$_buf='';
    }
    $_=<>; ##-- slurp more
  }
  ##--------------------------------------------
  else {
    ##-- other event (e.g. char): keep current block open
    $_=<>; ##-- slurp more
  }
  #print $_buf; ##-- dump last event
}
